<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>WebCamera 3D ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* è§†é¢‘åé¦ˆå°çª—å£ (ç”¨äºå¯¹å‡†æ‰‹åŠ¿) */
        .input_video {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            width: 160px; height: 120px; border-radius: 8px;
            transform: scaleX(-1); /* é•œåƒ */
            border: 2px solid rgba(255,255,255,0.2);
            opacity: 0.7;
        }

        /* UI é¢æ¿ */
        #ui-container {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px; border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            color: white; width: 260px;
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 12px; color: #888; letter-spacing: 1px;}
        select, input[type="color"], input[type="range"] {
            width: 100%; padding: 5px; border-radius: 4px; border: none;
            background: #222; color: white; outline: none;
        }
        
        /* çŠ¶æ€åŠ è½½å±‚ */
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #00d2ff; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #00d2ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #status-text { font-size: 14px; color: #00ff88; margin-top: 10px; text-align: center;}
    </style>

    <!-- 1. å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- 2. å¼•å…¥ MediaPipe Hands (å…¨å±€è„šæœ¬æ–¹å¼å¼•å…¥æ›´ç¨³å®š) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- åŠ è½½åŠ¨ç”» -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI æ‰‹åŠ¿æ¨¡å‹...<br><span style="font-size:12px;color:#666">(åˆæ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ)</span></div>
    </div>

    <!-- æ‘„åƒå¤´æºè§†é¢‘ (éšè—/ç¼©å°) -->
    <video class="input_video"></video>
    
    <div id="canvas-container"></div>

    <div id="ui-container">
        <h3 style="margin:0 0 15px 0; border-bottom:1px solid #333; padding-bottom:10px">ğŸ–ï¸ äº¤äº’æ§åˆ¶å°</h3>
        
        <div class="control-group">
            <label>æ¨¡å‹å½¢çŠ¶</label>
            <select id="modelSelect">
                <option value="galaxy">ğŸª æ˜Ÿç³» (Galaxy)</option>
                <option value="heart">â¤ï¸ èƒ½é‡ä¹‹å¿ƒ (Heart)</option>
                <option value="dna">ğŸ§¬ åŒèºæ—‹ (DNA)</option>
                <option value="cube">ğŸ§Š çŸ©é˜µæ–¹å— (Cube)</option>
            </select>
        </div>

        <div class="control-group">
            <label>åŸºç¡€é¢œè‰²</label>
            <input type="color" id="colorPicker" value="#0066ff">
        </div>

        <div id="status-text">ç­‰å¾…æ‘„åƒå¤´æˆæƒ...</div>
        <button onclick="document.body.requestFullscreen()" style="width:100%; margin-top:10px; background:#333; border:none; color:#fff; padding:8px; cursor:pointer; border-radius:4px;">è¿›å…¥å…¨å±</button>
    </div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ================= æ ¸å¿ƒçŠ¶æ€å˜é‡ =================
const CONFIG = {
    particleCount: 12000,
    baseSize: 0.6,
    handDistance: 0, // 0 (é—­åˆ) ~ 1 (æœ€å¤§å¼ å¼€)
    targetColor: new THREE.Color(0x0066ff),
    currentShape: 'galaxy'
};

// DOM å…ƒç´ 
const videoElement = document.getElementsByClassName('input_video')[0];
const statusText = document.getElementById('status-text');
const loadingOverlay = document.getElementById('loading-overlay');

// Three.js å˜é‡
let scene, camera, renderer, composer, particles;
let targetPositions = new Float32Array(CONFIG.particleCount * 3);

// ================= 1. æ‘„åƒå¤´ä¸ AI åˆå§‹åŒ– (MediaPipe) =================
function initMediaPipe() {
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    cameraUtils.start()
        .then(() => {
            statusText.innerText = "âœ… æ‘„åƒå¤´è¿è¡Œä¸­";
            loadingOverlay.style.opacity = '0';
            setTimeout(() => loadingOverlay.style.display = 'none', 500);
        })
        .catch(err => {
            statusText.innerText = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.message;
            statusText.style.color = "red";
            loadingOverlay.innerHTML = "<h3>æ— æ³•è®¿é—®æ‘„åƒå¤´</h3><p>è¯·ç¡®ä¿å…è®¸æƒé™æˆ–ä½¿ç”¨ HTTPS/Localhost è®¿é—®</p>";
        });
}

// AI ç»“æœå¤„ç†å›è°ƒ
function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        statusText.innerText = `ğŸ–ï¸ æ£€æµ‹åˆ° ${results.multiHandLandmarks.length} åªæ‰‹`;
        
        let dist = 0;

        // é€»è¾‘ï¼šå¦‚æœæœ‰ä¸¤åªæ‰‹ï¼Œè®¡ç®—ä¸¤æ‰‹ä¸­å¿ƒè·ç¦»
        if (results.multiHandLandmarks.length === 2) {
            const hand1 = results.multiHandLandmarks[0][9]; // ä¸­æŒ‡æ ¹éƒ¨
            const hand2 = results.multiHandLandmarks[1][9];
            // ç®€å•æ¬§å‡ é‡Œå¾—è·ç¦»
            const dx = hand1.x - hand2.x;
            const dy = hand1.y - hand2.y;
            dist = Math.sqrt(dx*dx + dy*dy);
            // æ˜ å°„è·ç¦»ï¼šé€šå¸¸ä¸¤æ‰‹è·ç¦»åœ¨ 0.1 åˆ° 0.8 ä¹‹é—´
            dist = (dist - 0.1) * 1.5; 
        } 
        // é€»è¾‘ï¼šå¦‚æœåªæœ‰ä¸€åªæ‰‹ï¼Œè®¡ç®—æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)è·ç¦»
        else {
            const lm = results.multiHandLandmarks[0];
            const dx = lm[4].x - lm[8].x;
            const dy = lm[4].y - lm[8].y;
            dist = Math.sqrt(dx*dx + dy*dy);
            // æ˜ å°„è·ç¦»ï¼šå•æ‰‹æåˆé€šå¸¸åœ¨ 0.02 åˆ° 0.2 ä¹‹é—´
            dist = (dist - 0.02) * 5.0;
        }

        // å¹³æ»‘å¤„ç†è¾“å…¥å€¼ (Clamp 0~1)
        CONFIG.handDistance = THREE.MathUtils.lerp(CONFIG.handDistance, Math.max(0, Math.min(1, dist)), 0.1);
    } else {
        statusText.innerText = "ğŸ” å¯»æ‰¾æ‰‹åŠ¿ä¸­...";
        // æœªæ£€æµ‹åˆ°æ‰‹æ—¶ç¼“æ…¢å¤åŸ
        CONFIG.handDistance = THREE.MathUtils.lerp(CONFIG.handDistance, 0.2, 0.05);
    }
}

// ================= 2. Three.js åœºæ™¯åˆå§‹åŒ– =================
function initThree() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    // è¿œæ™¯é›¾æ°”
    scene.fog = new THREE.FogExp2(0x000000, 0.015);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // åæœŸå¤„ç† - è¾‰å…‰ (Bloom)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 2.0;
    bloomPass.radius = 0.5;
    bloomPass.threshold = 0;

    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // åˆ›å»ºç²’å­
    createParticles();
    // ç”Ÿæˆåˆå§‹å½¢çŠ¶
    updateShape('galaxy');

    // äº‹ä»¶
    window.addEventListener('resize', onWindowResize);
    
    // UIç»‘å®š
    document.getElementById('modelSelect').addEventListener('change', (e) => {
        CONFIG.currentShape = e.target.value;
        updateShape(e.target.value);
    });
    document.getElementById('colorPicker').addEventListener('input', (e) => {
        CONFIG.targetColor.set(e.target.value);
    });

    animate();
}

// åˆ›å»ºç²’å­ç³»ç»Ÿ
function createParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    
    // éšæœºåˆå§‹ä½ç½®
    for(let i=0; i<CONFIG.particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // åˆ›å»ºå‘å…‰çº¹ç†
    const texture = getSprite();

    const material = new THREE.PointsMaterial({
        color: CONFIG.targetColor,
        size: CONFIG.baseSize,
        map: texture,
        blending: THREE.AdditiveBlending, // å åŠ å‘å…‰
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

// ç”Ÿæˆä¸åŒå½¢çŠ¶çš„ç‚¹äº‘æ•°æ®
function updateShape(type) {
    const pos = targetPositions;
    const count = CONFIG.particleCount;
    
    for(let i=0; i<count; i++) {
        let x, y, z;
        const idx = i * 3;
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        if (type === 'heart') {
             // çˆ±å¿ƒå…¬å¼
             const t = u * Math.PI * 2;
             // å†…éƒ¨å¡«å……éšæœºåŒ–
             const r = 12 * Math.sqrt(Math.random());
             x = 16 * Math.pow(Math.sin(t), 3);
             y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
             // ç¼©æ”¾å¹¶æ·»åŠ åšåº¦
             x *= (r/12); y *= (r/12);
             z = (Math.random()-0.5) * 8;
        } 
        else if (type === 'galaxy') {
            // æ—‹æ¶¡
            const angle = u * Math.PI * 2 * 3; // 3åœˆ
            const radius = v * 25;
            x = Math.cos(angle + radius * 0.1) * radius;
            z = Math.sin(angle + radius * 0.1) * radius;
            y = (Math.random()-0.5) * (radius * 0.2); // ä¸­å¿ƒåšï¼Œè¾¹ç¼˜è–„
        }
        else if (type === 'dna') {
            const h = (u - 0.5) * 60;
            const angle = h * 0.5;
            const radius = 6;
            // åŒé“¾åˆ¤æ–­
            const offset = (i % 2 === 0) ? 0 : Math.PI;
            x = Math.cos(angle + offset) * radius + (Math.random()-0.5)*2;
            z = Math.sin(angle + offset) * radius + (Math.random()-0.5)*2;
            y = h;
        }
        else {
            // Cube (é»˜è®¤)
            const s = 25;
            x = (Math.random() - 0.5) * s;
            y = (Math.random() - 0.5) * s;
            z = (Math.random() - 0.5) * s;
        }
        
        pos[idx] = x;
        pos[idx+1] = y;
        pos[idx+2] = z;
    }
}

function getSprite() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(canvas);
}

// ================= 3. æ¸²æŸ“å¾ªç¯ =================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const time = clock.getElapsedTime();
    const positions = particles.geometry.attributes.position.array;
    
    // æ‰‹åŠ¿å½±å“å› å­
    // å¼ å¼€è¶Šå¤§ -> ç²’å­è¶Šæ‰©æ•£ï¼Œéœ‡åŠ¨è¶Šå¼º
    const scale = 1 + CONFIG.handDistance * 1.2; 
    const noise = CONFIG.handDistance * 0.8;
    
    // ç²’å­æ—‹è½¬
    particles.rotation.y = time * 0.1;

    // æ ¸å¿ƒåŠ¨ç”»é€»è¾‘ï¼šè®©å½“å‰ç‚¹é£å‘ç›®æ ‡ç‚¹
    for(let i=0; i<CONFIG.particleCount; i++) {
        const idx = i * 3;
        
        // ç›®æ ‡åŸºç¡€ä½ç½®
        const tx = targetPositions[idx];
        const ty = targetPositions[idx+1];
        const tz = targetPositions[idx+2];

        // è®¡ç®—åŠ¨æ€ä½ç½®ï¼šåŸºç¡€ä½ç½® * ç¼©æ”¾ + å™ªç‚¹éœ‡åŠ¨
        const targetX = tx * scale + (Math.random()-0.5) * noise * 5;
        const targetY = ty * scale + (Math.random()-0.5) * noise * 5;
        const targetZ = tz * scale + (Math.random()-0.5) * noise * 5;

        // Lerp æ’å€¼ç§»åŠ¨ (0.08 æ˜¯ç§»åŠ¨é€Ÿåº¦ï¼Œè¶Šå°è¶Šæ»åå¹³æ»‘)
        positions[idx] += (targetX - positions[idx]) * 0.08;
        positions[idx+1] += (targetY - positions[idx+1]) * 0.08;
        positions[idx+2] += (targetZ - positions[idx+2]) * 0.08;
    }

    particles.geometry.attributes.position.needsUpdate = true;
    
    // é¢œè‰²å®æ—¶æ··åˆ
    particles.material.color.lerp(CONFIG.targetColor, 0.1);
    // å¼ å¼€æ—¶ç²’å­å˜äº®
    particles.material.opacity = 0.6 + CONFIG.handDistance * 0.4;

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

// ================= å¯åŠ¨ =================
initThree();
initMediaPipe();

</script>
</body>
</html>