<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æœªæ¥å…¨æ¯ç‚¹é¤ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* è§†é¢‘åé¦ˆ (é•œåƒ) */
        .input_video {
            position: absolute; bottom: 20px; left: 20px; width: 120px; border-radius: 10px;
            transform: scaleX(-1); border: 1px solid #333; opacity: 0.5; z-index: 10;
        }

        /* é¡¶éƒ¨ HUD */
        #header {
            position: absolute; top: 20px; left: 0; width: 100%; text-align: center;
            pointer-events: none; z-index: 20;
        }
        h1 {
            color: #fff; margin: 0; font-weight: 300; letter-spacing: 5px;
            text-shadow: 0 0 20px #00d2ff; font-size: 24px;
        }
        p { color: #888; font-size: 12px; text-transform: uppercase; margin-top: 5px; }

        /* è´­ç‰©è½¦æ¸…å• */
        #cart-panel {
            position: absolute; top: 80px; right: 20px; width: 220px;
            background: rgba(10, 15, 20, 0.8); backdrop-filter: blur(10px);
            border-left: 2px solid #00d2ff; padding: 20px; color: #fff;
            border-radius: 0 0 0 20px; z-index: 20;
            box-shadow: -10px 10px 30px rgba(0,0,0,0.5);
        }
        .cart-title { font-size: 14px; color: #00d2ff; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        #cart-items { height: 200px; overflow-y: auto; font-size: 13px; margin-bottom: 10px; }
        .cart-item { display: flex; justify-content: space-between; margin-bottom: 5px; animation: slideIn 0.3s; }
        #total-price { font-size: 20px; font-weight: bold; text-align: right; color: #00ff88; }

        /* äº¤äº’æç¤ºå…‰åœˆ */
        #cursor-follower {
            position: absolute; width: 40px; height: 40px;
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 30;
            transition: border-color 0.2s, transform 0.1s;
            display: none; /* é»˜è®¤éšè—ï¼Œç”± JS æ§åˆ¶ */
        }
        
        /* åŠ è½½å±‚ */
        #loading {
            position: absolute; inset: 0; background: #000; color: #00d2ff;
            display: flex; justify-content: center; align-items: center; z-index: 100;
            flex-direction: column;
        }

        @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    </style>

    <!-- å¼•å…¥ Three.js å’Œ MediaPipe -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div style="font-size: 40px; margin-bottom: 20px;">ğŸ½ï¸</div>
        <div>åˆå§‹åŒ–å…¨æ¯èœå•ç³»ç»Ÿ...</div>
    </div>

    <div id="header">
        <h1>HOLO-MENU</h1>
        <p>å·¦å³æŒ¥æ‰‹åˆ‡æ¢ | æåˆæ‰‹æŒ‡ä¸‹å•</p>
    </div>

    <div id="cart-panel">
        <div class="cart-title">å½“å‰è®¢å• (CART)</div>
        <div id="cart-items">
            <div style="color:#555; text-align:center; margin-top:20px;">ç©ºç©ºå¦‚ä¹Ÿ</div>
        </div>
        <div id="total-price">Â¥ 0.00</div>
    </div>

    <div id="cursor-follower"></div>
    <video class="input_video"></video>
    <div id="canvas-container"></div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ================= å…¨å±€å˜é‡ =================
const STATE = {
    handX: 0.5, // 0-1
    handY: 0.5,
    isPinching: false,
    pinchProgress: 0,
    rotationTarget: 0,
    selectedIndex: 0,
    cartTotal: 0
};

const MENU_DATA = [
    { id: 'burger', name: 'èµ›åšæ±‰å ¡', price: 48, color: 0xffaa00 },
    { id: 'drink', name: 'é‡å­èƒ½é‡é¥®', price: 25, color: 0x00d2ff },
    { id: 'pizza', name: 'åé‡åŠ›æŠ«è¨', price: 88, color: 0xff4400 },
    { id: 'icecream', name: 'æ¶²æ°®å†°æ·‡æ·‹', price: 35, color: 0xff00aa },
    { id: 'sushi', name: 'å…¨æ¯å¯¿å¸æ‹¼ç›˜', price: 128, color: 0x00ff88 }
];

let scene, camera, renderer, composer;
let menuGroup; // æ—‹è½¬ç›˜
let cursorMesh; // 3D å…‰æ ‡
let progressRing; // ç¡®è®¤è¿›åº¦æ¡
const menuItems = [];
const clock = new THREE.Clock();

// ================= åˆå§‹åŒ–å…¥å£ =================
initThree();
initAI();

function initThree() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 12);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const spotLight = new THREE.SpotLight(0xffffff, 50);
    spotLight.position.set(0, 10, 10);
    spotLight.angle = 0.5;
    spotLight.penumbra = 1;
    scene.add(spotLight);

    // åæœŸè¾‰å…‰
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.8;
    bloomPass.threshold = 0;
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // åˆ›å»ºåœºæ™¯å†…å®¹
    createEnvironment();
    createMenuSystem();
    createCursor();

    window.addEventListener('resize', onResize);
    animate();
}

// ================= åœºæ™¯æ„å»º =================

function createEnvironment() {
    // åœ°é¢ç½‘æ ¼
    const grid = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
    scene.add(grid);
    
    // èƒŒæ™¯ç²’å­
    const geo = new THREE.BufferGeometry();
    const pos = [];
    for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*50, (Math.random()-0.5)*30, (Math.random()-0.5)*30);
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({color: 0x444444, size: 0.1});
    scene.add(new THREE.Points(geo, mat));
}

function createMenuSystem() {
    menuGroup = new THREE.Group();
    scene.add(menuGroup);

    const radius = 6;
    const angleStep = (Math.PI * 2) / MENU_DATA.length;

    MENU_DATA.forEach((data, i) => {
        const itemGroup = new THREE.Group();
        const angle = i * angleStep;

        // 1. ç”ŸæˆæŠ½è±¡é£Ÿç‰©æ¨¡å‹
        const mesh = generateFoodModel(data.id, data.color);
        itemGroup.add(mesh);

        // 2. åº•éƒ¨æ‰˜ç›˜
        const tray = new THREE.Mesh(
            new THREE.CylinderGeometry(1.2, 1.0, 0.1, 32),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 })
        );
        tray.position.y = -1;
        itemGroup.add(tray);

        // 3. æ–‡å­—æ ‡ç­¾ (Canvasè´´å›¾)
        const label = createLabel(data.name, "Â¥" + data.price);
        label.position.set(0, 2.5, 0);
        itemGroup.add(label);

        // ä½ç½®è®¡ç®—
        itemGroup.position.x = Math.sin(angle) * radius;
        itemGroup.position.z = Math.cos(angle) * radius;
        itemGroup.rotation.y = angle; // é¢å‘ä¸­å¿ƒ
        
        itemGroup.userData = { ...data, originalY: 0 };
        menuItems.push(itemGroup);
        menuGroup.add(itemGroup);
    });
}

// ç®€å•çš„ç¨‹åºåŒ–é£Ÿç‰©æ¨¡å‹ç”Ÿæˆå™¨
function generateFoodModel(type, color) {
    const mat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.3, roughness: 0.4, emissive: color, emissiveIntensity: 0.2 });
    let mesh;

    if(type === 'burger') {
        mesh = new THREE.Group();
        const bunBottom = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16), mat);
        const meat = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.85, 0.2, 16), new THREE.MeshStandardMaterial({color:0x552200}));
        const cheese = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 1.5), new THREE.MeshBasicMaterial({color:0xffcc00}));
        const bunTop = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI*2, 0, Math.PI/2), mat);
        
        bunBottom.position.y = -0.5; meat.position.y = -0.2; cheese.position.y = 0; bunTop.position.y = 0.1;
        mesh.add(bunBottom, meat, cheese, bunTop);
    } 
    else if (type === 'drink') {
        mesh = new THREE.Group();
        const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.4, 1.8, 16), mat);
        const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5), new THREE.MeshBasicMaterial({color:0xffffff}));
        straw.rotation.z = 0.2; straw.position.y = 0.5;
        mesh.add(cup, straw);
    }
    else if (type === 'pizza') {
        mesh = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.1, 32), mat);
        // Toppings
        for(let i=0; i<5; i++){
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.15), new THREE.MeshBasicMaterial({color:0xff0000}));
            p.position.set(Math.sin(i)*0.6, 0.1, Math.cos(i)*0.6);
            mesh.add(p);
        }
        mesh.add(base);
        mesh.rotation.x = 0.5; // å€¾æ–œå±•ç¤º
    }
    else if (type === 'icecream') {
        mesh = new THREE.Group();
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.5, 16, 1, true), new THREE.MeshStandardMaterial({color:0xaa8855}));
        cone.rotation.x = Math.PI; cone.position.y = -0.5;
        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), mat);
        ball.position.y = 0.4;
        mesh.add(cone, ball);
    }
    else {
        // é»˜è®¤æ–¹å—
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), mat);
    }
    
    return mesh;
}

function createLabel(text, price) {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // èƒŒæ™¯æ¡†
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.roundRect(10, 10, 236, 108, 20);
    ctx.fill();
    ctx.strokeStyle = '#00d2ff';
    ctx.lineWidth = 4;
    ctx.stroke();

    // æ–‡å­—
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(text, 128, 60);
    
    ctx.fillStyle = '#00ff88';
    ctx.font = '30px Arial';
    ctx.fillText(price, 128, 100);

    const tex = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.scale.set(3, 1.5, 1);
    return sprite;
}

function createCursor() {
    // 3D ç©ºé—´ä¸­çš„å…‰æ ‡ (ä¸€ä¸ªè·Ÿéšæ‰‹æŒ‡çš„åœ†ç¯)
    const geo = new THREE.RingGeometry(0.3, 0.35, 32);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
    cursorMesh = new THREE.Mesh(geo, mat);
    cursorMesh.position.z = 8; // æ”¾åœ¨èœå•å‰é¢
    scene.add(cursorMesh);

    // è¿›åº¦æ¡åœ†ç¯ (ä¸‹å•åŠ è½½åœˆ)
    const pGeo = new THREE.RingGeometry(0.4, 0.5, 32, 1, 0, 0);
    const pMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff, side: THREE.DoubleSide });
    progressRing = new THREE.Mesh(pGeo, pMat);
    progressRing.position.z = 0.01; // ç¨å¾®åœ¨å…‰æ ‡å‰
    cursorMesh.add(progressRing);
}

// ================= æ‰‹åŠ¿è¯†åˆ« =================

function initAI() {
    const video = document.getElementsByClassName('input_video')[0];
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 640, height: 480
    });
    cameraUtils.start().then(() => {
        document.getElementById('loading').style.display = 'none';
    });
}

function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const lm = results.multiHandLandmarks[0];
        
        // 1. è¿½è¸ªé£ŸæŒ‡å°– (8) æ§åˆ¶å…‰æ ‡
        // åæ ‡æ˜ å°„ï¼šMediaPipe x(0-1) -> å±å¹•åæ ‡ -> 3Dåæ ‡
        // ç®€å•å¤„ç†ï¼šMediaPipe x ç¿»è½¬ (é•œåƒ)
        const x = 1 - lm[8].x; 
        const y = 1 - lm[8].y; 

        STATE.handX = THREE.MathUtils.lerp(STATE.handX, x, 0.1);
        STATE.handY = THREE.MathUtils.lerp(STATE.handY, y, 0.1);

        // 2. æåˆæ£€æµ‹ (é£ŸæŒ‡ 8 å’Œ æ‹‡æŒ‡ 4 çš„è·ç¦»)
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 0.05) {
            STATE.isPinching = true;
        } else {
            STATE.isPinching = false;
        }

        // 3. æ›´æ–° HTML ä¸Šçš„å…‰æ ‡è·Ÿéšå™¨ (è§†è§‰åé¦ˆ)
        const follower = document.getElementById('cursor-follower');
        follower.style.display = 'block';
        follower.style.left = (STATE.handX * 100) + '%';
        follower.style.top = (STATE.handY * 100) + '%';
        
        if(STATE.isPinching) {
            follower.style.transform = 'translate(-50%, -50%) scale(0.8)';
            follower.style.borderColor = '#00d2ff';
        } else {
            follower.style.transform = 'translate(-50%, -50%) scale(1.0)';
            follower.style.borderColor = 'rgba(255,255,255,0.5)';
        }

    } else {
        STATE.isPinching = false;
        document.getElementById('cursor-follower').style.display = 'none';
    }
}

// ================= æ¸²æŸ“å¾ªç¯ä¸é€»è¾‘ =================

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // 1. æ›´æ–° 3D å…‰æ ‡ä½ç½®
    // å°† 0-1 çš„å±å¹•ç©ºé—´ æ˜ å°„åˆ° ç›¸æœºå‰çš„ 3D å¹³é¢
    const vec = new THREE.Vector3();
    const pos = new THREE.Vector3();
    vec.set((STATE.handX * 2) - 1, -(STATE.handY * 2) + 1, 0.5);
    vec.unproject(camera);
    vec.sub(camera.position).normalize();
    const distance = 10; // å…‰æ ‡è·ç¦»ç›¸æœºçš„æ·±åº¦
    pos.copy(camera.position).add(vec.multiplyScalar(distance));
    cursorMesh.position.lerp(pos, 0.2);

    // 2. èœå•æ—‹è½¬é€»è¾‘ (åŸºäºæ‰‹æŒæ°´å¹³ä½ç½®)
    // å¦‚æœæ‰‹åœ¨å·¦ä¾§ (<0.3) å‘å·¦è½¬ï¼Œå³ä¾§ (>0.7) å‘å³è½¬
    if (STATE.handX < 0.3) {
        STATE.rotationTarget -= 1.5 * dt;
    } else if (STATE.handX > 0.7) {
        STATE.rotationTarget += 1.5 * dt;
    }
    
    // æƒ¯æ€§å¹³æ»‘æ—‹è½¬
    menuGroup.rotation.y += (STATE.rotationTarget - menuGroup.rotation.y) * 0.1;

    // 3. ç¡®å®šå½“å‰é€‰ä¸­çš„èœå“ (ç¦»ç›¸æœºæœ€è¿‘çš„)
    // è®¡ç®—æ—‹è½¬è§’åº¦å¯¹åº”çš„ Index
    const step = (Math.PI * 2) / MENU_DATA.length;
    // è§„èŒƒåŒ–è§’åº¦åˆ° 0 - 2PI
    let currentRot = menuGroup.rotation.y % (Math.PI * 2);
    if (currentRot < 0) currentRot += Math.PI * 2;
    
    // åæ¨ç´¢å¼• (æœ€å‰é¢çš„ç‰©å“ç´¢å¼•)
    // ç¨å¾®è°ƒæ•´ç›¸ä½ä½¿å¾— 0 åº¦å¯¹åº” index 0
    let activeIndex = Math.round(currentRot / step); 
    activeIndex = (MENU_DATA.length - activeIndex) % MENU_DATA.length;
    if(activeIndex < 0) activeIndex += MENU_DATA.length;
    
    STATE.selectedIndex = activeIndex;

    // 4. ç‰©å“é«˜äº®ä¸åŠ¨ç”»
    menuItems.forEach((item, i) => {
        if (i === activeIndex) {
            // é€‰ä¸­æ€ï¼šæ”¾å¤§ï¼Œä¸Šä¸‹æµ®åŠ¨
            const scale = THREE.MathUtils.lerp(item.scale.x, 1.5, 0.1);
            item.scale.setScalar(scale);
            item.position.y = Math.sin(time * 3) * 0.2 + 0.5;
        } else {
            // æ™®é€šæ€
            const scale = THREE.MathUtils.lerp(item.scale.x, 1.0, 0.1);
            item.scale.setScalar(scale);
            item.position.y = THREE.MathUtils.lerp(item.position.y, 0, 0.1);
        }
    });

    // 5. ä¸‹å•äº¤äº’é€»è¾‘
    updateOrderLogic(dt);

    composer.render();
}

function updateOrderLogic(dt) {
    // åªæœ‰å½“æåˆæ—¶ï¼Œä¸”å½“å‰æœ‰é€‰ä¸­é¡¹
    if (STATE.isPinching) {
        STATE.pinchProgress += dt * 1.5; // 0.6ç§’å·¦å³å……æ»¡
    } else {
        STATE.pinchProgress = 0;
    }

    // æ›´æ–°è¿›åº¦æ¡åœ†ç¯å‡ ä½•ä½“
    const p = Math.min(STATE.pinchProgress, 1.0);
    // é‡æ–°ç”Ÿæˆå‡ ä½•ä½“æ¥æ”¹å˜å¼§åº¦ (Three.js é™åˆ¶)
    progressRing.geometry.dispose();
    progressRing.geometry = new THREE.RingGeometry(0.4, 0.5, 32, 1, 0, p * Math.PI * 2);
    progressRing.rotation.z = -Math.PI / 2; // ä»é¡¶éƒ¨å¼€å§‹

    // è§¦å‘ä¸‹å•
    if (STATE.pinchProgress >= 1.0) {
        addToCart(MENU_DATA[STATE.selectedIndex]);
        STATE.pinchProgress = 0; // é‡ç½®
        STATE.isPinching = false; // å¼ºåˆ¶é‡Šæ”¾é˜²æ­¢è¿ç»­è§¦å‘
        
        // è§¦å‘ç‰¹æ•ˆï¼šé€‰ä¸­ç‰©å“éœ‡åŠ¨ä¸€ä¸‹
        const activeItem = menuItems[STATE.selectedIndex];
        activeItem.scale.setScalar(2.0); // ç¬é—´æ”¾å¤§
    }
}

function addToCart(item) {
    const cartList = document.getElementById('cart-items');
    // å¦‚æœæ˜¯ç©ºæç¤ºï¼Œå…ˆæ¸…ç©º
    if(cartList.children[0] && cartList.children[0].innerText === 'ç©ºç©ºå¦‚ä¹Ÿ') {
        cartList.innerHTML = '';
    }

    const div = document.createElement('div');
    div.className = 'cart-item';
    div.innerHTML = `<span>${item.name}</span><span>Â¥${item.price}</span>`;
    cartList.appendChild(div);
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    cartList.scrollTop = cartList.scrollHeight;

    // æ›´æ–°æ€»ä»·
    STATE.cartTotal += item.price;
    document.getElementById('total-price').innerText = 'Â¥ ' + STATE.cartTotal.toFixed(2);

    // åˆ›å»ºä¸€ä¸ªé£å…¥ç²’å­çš„ç®€æ˜“ç‰¹æ•ˆ (å¯é€‰)
    // è¿™é‡Œç®€å•ç”¨ console log ä»£æ›¿ï¼Œå®é™…å¯ä»¥é€šè¿‡ HTML å…ƒç´ åšé£å…¥åŠ¨ç”»
    console.log(`Ordered: ${item.name}`);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>